import type { TPayment, TPaymentCreate } from '@packages/domain'
import type { PaymentsRepository, UsersRepository, UnitsRepository, CurrenciesRepository } from '@database/repositories'
import { type TServiceResult, success, failure } from '../base.service'

export interface ICreatePaymentInput {
  userId: string
  unitId: string
  amount: string
  currencyId: string
  paymentMethod: TPayment['paymentMethod']
  paymentGatewayId?: string | null
  paymentDetails?: Record<string, unknown> | null
  paymentDate: string
  receiptUrl?: string | null
  receiptNumber?: string | null
  notes?: string | null
  registeredByUserId: string
}

export interface ICreatePaymentOutput {
  payment: TPayment
  message: string
}

/**
 * Service for creating a new payment.
 * Creates payment with 'pending' status for gateway/automatic processing,
 * or 'pending_verification' for manual payment methods.
 */
export class CreatePaymentService {
  constructor(
    private readonly paymentsRepository: PaymentsRepository,
    private readonly usersRepository: UsersRepository,
    private readonly unitsRepository: UnitsRepository,
    private readonly currenciesRepository: CurrenciesRepository
  ) {}

  async execute(input: ICreatePaymentInput): Promise<TServiceResult<ICreatePaymentOutput>> {
    // 1. Validate user exists
    const user = await this.usersRepository.getById(input.userId)
    if (!user) {
      return failure('User not found', 'NOT_FOUND')
    }

    // 2. Validate unit exists
    const unit = await this.unitsRepository.getById(input.unitId)
    if (!unit) {
      return failure('Unit not found', 'NOT_FOUND')
    }

    // 3. Validate currency exists and is active
    const currency = await this.currenciesRepository.getById(input.currencyId)
    if (!currency) {
      return failure('Currency not found', 'NOT_FOUND')
    }

    if (!currency.isActive) {
      return failure('Currency is not active', 'BAD_REQUEST')
    }

    // 4. Validate amount is positive
    const amount = parseFloat(input.amount)
    if (isNaN(amount) || amount <= 0) {
      return failure('Amount must be a positive number', 'BAD_REQUEST')
    }

    // 5. Determine initial status based on payment method
    // Gateway payments start as 'pending' for automatic processing
    // Manual methods (transfer, cash, card, mobile_payment) start as 'pending_verification'
    const status: TPayment['status'] = input.paymentMethod === 'gateway'
      ? 'pending'
      : 'pending_verification'

    // 6. Create payment
    const paymentData: TPaymentCreate = {
      paymentNumber: null, // Will be generated by DB trigger or service
      userId: input.userId,
      unitId: input.unitId,
      amount: input.amount,
      currencyId: input.currencyId,
      paidAmount: null,
      paidCurrencyId: null,
      exchangeRate: null,
      paymentMethod: input.paymentMethod,
      paymentGatewayId: input.paymentGatewayId ?? null,
      paymentDetails: input.paymentDetails ?? null,
      paymentDate: input.paymentDate,
      status,
      receiptUrl: input.receiptUrl ?? null,
      receiptNumber: input.receiptNumber ?? null,
      notes: input.notes ?? null,
      metadata: null,
      registeredBy: input.registeredByUserId,
    }

    const payment = await this.paymentsRepository.create(paymentData)

    const message = status === 'pending'
      ? 'Payment created and pending automatic processing'
      : 'Payment created and pending manual verification'

    return success({
      payment,
      message,
    })
  }
}
